{"meta":{"title":null,"subtitle":null,"description":null,"author":"fengjianxiong","url":"http://fengjianxiong.cn"},"pages":[{"title":"","date":"2018-03-19T20:14:56.132Z","updated":"2018-03-19T20:14:56.132Z","comments":true,"path":"404.html","permalink":"http://fengjianxiong.cn/404.html","excerpt":"","text":""},{"title":"","date":"2018-03-27T12:16:05.526Z","updated":"2018-03-27T12:16:05.526Z","comments":true,"path":"about/index.html","permalink":"http://fengjianxiong.cn/about/index.html","excerpt":"","text":"赞助辣条快向我丢辣条~ 联系方式：fjx9303@vip.qq.com"}],"posts":[{"title":"shell中if语句的使用","slug":"shellif","date":"2018-04-20T16:44:14.000Z","updated":"2018-04-20T17:04:09.583Z","comments":true,"path":"2018/04/21/shellif/","link":"","permalink":"http://fengjianxiong.cn/2018/04/21/shellif/","excerpt":"","text":"转自：http://lovelace.blog.51cto.com/1028430/1211353 bash中如何实现条件判断？条件测试类型： 整数测试 字符测试 文件测试 一、条件测试的表达式： [ expression ] 括号两端必须要有空格 [[ expression ]] 括号两端必须要有空格 test expression组合测试条件： -a: and-o: or!: 非二、整数比较： -eq 测试两个整数是否相等-ne 测试两个整数是否不等-gt 测试一个数是否大于另一个数-lt 测试一个数是否小于另一个数-ge 大于或等于-le 小于或等于命令间的逻辑关系 逻辑与：&amp;&amp; 第一个条件为假 第二个条件不用在判断，最总结果已经有 第一个条件为真，第二个条件必须得判断 逻辑或：||三、字符串比较 == 等于 两边要有空格!= 不等 大于&lt; 小于四、文件测试 -z string 测试指定字符是否为空，空着真，非空为假-n string 测试指定字符串是否为不空，空为假 非空为真-e FILE 测试文件是否存在-f file 测试文件是否为普通文件-d file 测试指定路径是否为目录-r file 测试文件对当前用户是否可读-w file 测试文件对当前用户是否可写-x file 测试文件对当前用户是都可执行-z 是否为空 为空则为真-a 是否不空五、if语法12345678if 判断条件 0为真 其他都为假#####单分支if语句:if 判断条件；then statement1 statement2 .......fi #####双分支的if语句:12345678if 判断条件；then statement1 statement2 ..... else statement3 statement4fi Note:if语句进行判断是否为空\"$name\" 1等同于 [ ! “$name” ][ -z “$name” ]12345Note:使用if语句的时候进行判断如果是进行数值类的判断，建议使用let(())进行判断，对于字符串等使用test[ ] or [[ ]] 进行判断(())中变量是可以不使用$来引用的example：表述数字范围的时候 可以使用if可以是使用case if [ $x -gt 90 -o $x -lt 100 ]case $x in100)9[0-9])123这个语句的意思是如果$name为空，那么X=X成立折执行下面的结果；```if [ &quot;X$name&quot; != &quot;x&quot; ] 写脚本的时候很多时候需要用到回传命令，$?如果上一个命令执行成功，回传值为0，否则为1~255之间的任何一个 0为真非0为假条件测试的写法： 1、执行一个命令的结果grep -q \"rm\" fs.sh;then ```1232、传回一个命令执行结果的相反值``` if ！grep -q &quot;rm&quot; fs.sh;then 3、使用复合命令（（算式））((a>b));then ```1234、使用bash关键字 [[判断式]]``` if [[ str &gt; xyz ]];then 5、使用内置命令：test 判断式test \"str\" \\> \"xyz\";then ```1236、使用内置命令：[判断式] 类似test``` if [ &quot;str&quot; \\&gt; &quot;xyz&quot; ];then 7、使用-a -o进行逻辑组合-r filename -a -x filename ] ```1238、命令&amp;&amp;命令``` if grep -q &quot;rm&quot; fn.sh &amp;&amp; [ $a -lt 100 ];then 9、命令||命令grep -q \"rm\" fn.sh || [ $a -lt 100 ];then ```123456789101112131415161718####示例脚本（写一段脚本，输入一个测验成绩，根据下面的标准，输出他的评分成绩（A-F）。A: 90–100B: 80–89C: 70–79D: 60–69F: &lt;60） #/bin/bash #import an argumentread -p “Please input your grade:” xdeclare -i x #jugemet $x value is none or notif [ “$x” == “” ];then echo “You don’t input your grade….” exit 5fi #jugement the gread levelif [[ “$x” -ge “90” &amp;&amp; “$x” -le “100” ]];then echo “Congratulation,Your grade is A.”elif [[ “$x” -ge “80” &amp;&amp; “$x” -le “89” ]];then echo “Good,Your grade is B.”elif [[ “$x” -ge “70” &amp;&amp; “$x” -le “79” ]];then echo “Ok.Your grade is C.”elif [[ “$x” -ge “60” &amp;&amp; “$x” -le “69” ]];then echo “Yeah,Your grade is D.”elif [[ “$x” -lt “60” ]];then echo “Right,Your grade is F.”else echo “Unknow argument….”fi1执行结果： [root@lovelace if]# ./grade.sh Please input your grade: You don’t input your grade….[root@lovelace if]# ./grade.sh Please input your grade:53 Right,Your grade is F.[root@lovelace if]# ./grade.sh Please input your grade:88 Good,Your grade is B.` #####总结：条件判断在shell语句中经常用到，需要熟练掌握，在此基础上才能练就一手很好的脚本编写能力。祝各位每天都能获得很大的进步…..","categories":[{"name":"shell","slug":"shell","permalink":"http://fengjianxiong.cn/categories/shell/"}],"tags":[{"name":"shell;linux","slug":"shell-linux","permalink":"http://fengjianxiong.cn/tags/shell-linux/"}]},{"title":"什么是 ASN (自治系统号)","slug":"asn","date":"2018-04-10T17:41:42.000Z","updated":"2018-04-10T18:22:16.894Z","comments":true,"path":"2018/04/11/asn/","link":"","permalink":"http://fengjianxiong.cn/2018/04/11/asn/","excerpt":"","text":"自治系统（Autonomous System）用通俗的语言来形容，就是一个互联网的独立王国，这一个个独立王国互联起来，就组成了互联网（Internet）。每个王国有自己独立的国号，以区别于别的王国，这个国号用自治系统号ASN（Autonomous System Number），ASN由两个字节组成，理论上取值范围为 1-65535，末尾的1024个ASN是私有自治号，用于王国内部的下属郡国使用，不能外泄（类似私有IP，如果不小心外泄，别人也会忽略）。每一个互联网用户都置身于AS内，比如中国电信的AS号为 4809，那么中国电信的用户就置身于4809的独立王国，如果用户访问的服务器也是在这个AS内，那双向的流量都在王国里来回溜达。 但如果服务器IP位于中国移动AS内，如何跨运营商访问呢？运营商之间会使用BGP（Border Gateway Protocol) 路由协议来交换各自的IP路由表，AS号就是BGP协议用来辨识邻国的一个身份证，同时在交换的路由表信息里，会附上各自的AS号。既然中国电信通过BGP学习到中国移动的路由信息，就会把用户的访问请求转发给中国移动的边界路由器，既然IP包进入中国移动的地界，接下来就任由中国移动的设备来处理了，假设顺利到达服务器，回程检查客户IP，发现是电信的IP，就会转发到电信的边界路由器，并到达用户。 运营商属于合作、竞争关系，关系微妙如果运营商之间不互联，那运营商将会变成一个个孤岛，所以需要互联链路（桥梁）将孤岛连接起来，连接起来就会产生竞争关系。蛋糕就那么大，谁多吃一口，别人就会少吃一口，所以跨运营商的流量服务不会太好，带宽不足，容易丢包，延迟大。所以对于财大气粗的公司的服务器会提供多个运营商的入口IP，依据客户端IP归属哪个运营商（AS），智能DNS Server 会返回和客户端位于相同AS的服务器IP，这样客户端访问服务器就会低延迟、低丢包、快速响应。不光运营商可以拥有AS号，一些大型企业如 Google , Amonzon, Apple , EBay 都拥有自己的AS号，一个AS号通常足够使用，但运营商通常会有多个AS号，用于不同的独立的网络。","categories":[{"name":"知识","slug":"知识","permalink":"http://fengjianxiong.cn/categories/知识/"}],"tags":[{"name":"other","slug":"other","permalink":"http://fengjianxiong.cn/tags/other/"}]},{"title":"Github_Desktop-windows下载（不定期更新）","slug":"GithubDesktop","date":"2018-03-27T11:55:05.000Z","updated":"2018-04-10T17:58:58.848Z","comments":true,"path":"2018/03/27/GithubDesktop/","link":"","permalink":"http://fengjianxiong.cn/2018/03/27/GithubDesktop/","excerpt":"","text":"有很多网友表示github—desktop无法下载，有很多地方提供下载但是需要积分等繁琐得东西，这里就提供一个我自己得下载链接吧，以后会不定期更新。 GitHub Desktop的简单使用 百度云盘下载 密码：mu38","categories":[{"name":"资源","slug":"资源","permalink":"http://fengjianxiong.cn/categories/资源/"}],"tags":[{"name":"github","slug":"github","permalink":"http://fengjianxiong.cn/tags/github/"}]},{"title":"python实现readline去掉换行符\\n等特殊字符","slug":"python实现readline去掉换行符","date":"2018-03-21T20:19:21.000Z","updated":"2018-03-21T20:20:55.697Z","comments":true,"path":"2018/03/22/python实现readline去掉换行符/","link":"","permalink":"http://fengjianxiong.cn/2018/03/22/python实现readline去掉换行符/","excerpt":"","text":"刚刚用python的readline(s)读取文件的发现进行后续处理的时候总是会出现格式上等的一些小错误，后来想起来是因为文件换行符等一些符号（\\n\\r\\t）也会被readline(s)读取到，以下是我用到的小方法 举个栗子吧，以下是我的文件内容：123456In [1]: cat /tmp/ip.txt111.231.0.0/16122.152.0.0/16140.143.0.0/1659.110.0.0/16106.75.0.0/16 将文件读到变量 f 中，然后执行redline发现其实里面还包括了换行符 ‘\\n’：123In [2]: f = open(&quot;/tmp/ip.txt&quot;,&apos;r&apos;)In [3]: f.readline()Out[3]: &apos;111.231.0.0/16\\n&apos; 我们可以通过split方法将需要的内容切割出来得到下面的结果，但是还不是我们真正想要的，此时的结果为一个列表：12In [4]: f.readline().split(&quot;\\n&quot;)Out[4]: [&apos;122.152.0.0/16&apos;, &apos;&apos;] 最后我们可以通过索引的方式将前面的内容取出，达到目的，最后将这个内容送到其他的流程进行处理即可。12In [5]: f.readline().split(&quot;\\n&quot;)[0]Out[5]: &apos;140.143.0.0/16&apos; 可能有的同学会问，那\\r\\t\\n都存在的情况呢？那我们就直接让他们消失😄！比如目前读到的行为1&apos;\\t192.168.11.10/32\\n&apos; 通过replace方法替换成空：1a = f.readline().replace(&apos;\\r&apos;,&apos;&apos;).replace(&apos;\\n&apos;,&apos;&apos;).replace(&apos;\\t&apos;,&apos;&apos;) 还可以通过re模块的sub方法：Sub(replacement,string[,count =0 ]) 12345In [37]: import reIn [38]: a=re.compile(&apos;(\\t|\\n|\\r)&apos;)In [39]: b=a.sub(&apos;$&apos;,&apos;\\t111.231\\r.0.0/16\\n&apos;) #后面的内容通过定义的正则，将符合的内容替换成&apos;$&apos;处的内容In [40]: bOut[41]: &apos;$111.231$.0.0/16$&apos; 内容比较简单，希望可以帮到需要的同学","categories":[{"name":"python","slug":"python","permalink":"http://fengjianxiong.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://fengjianxiong.cn/tags/python/"}]},{"title":"Python中read()、readline()和readlines()三者间的区别和用法","slug":"Python中read、readline和readlines三者间的区别和用法","date":"2018-03-19T17:42:31.000Z","updated":"2018-03-19T20:46:54.028Z","comments":true,"path":"2018/03/20/Python中read、readline和readlines三者间的区别和用法/","link":"","permalink":"http://fengjianxiong.cn/2018/03/20/Python中read、readline和readlines三者间的区别和用法/","excerpt":"","text":"==前言==众所周知在python中读取文件常用的三种方法：read(),readline(),readlines()，今天看项目是又忘记他们的区别了。以前看书的时候觉得这东西很简单，一眼扫过，待到用时却也只知道有这么几个方法，不懂得它的原理与用法。也许吧，没有永远的记忆，况且根本没有用心去记它。话不多说，来一起看看详细的介绍： ==准备==假设a.txt的内容如下所示： 123HelloWelcomeWhat is the fuck... 一、read([size])方法 read([size])方法从文件当前位置起读取size个字节，若无参数size，则表示读取至文件结束为止，它范围为字符串对象 12345f = open(&quot;a.txt&quot;)lines = f.read()print linesprint(type(lines))f.close() 输出结果：1234HelloWelcomeWhat is the fuck...&lt;type &apos;str&apos;&gt; #字符串类型 二、readline()方法 从字面意思可以看出，该方法每次读出一行内容，所以，读取时占用内存小，比较适合大文件，该方法返回一个字符串对象。 1234567f = open(&quot;a.txt&quot;)line = f.readline()print(type(line))while line: print line, line = f.readline()f.close() 输出结果： 1234&lt;type &apos;str&apos;&gt;HelloWelcomeWhat is the fuck... 三、readlines()方法读取整个文件所有行，保存在一个列表(list)变量中，每行作为一个元素，但读取大文件会比较占内存。 123456f = open(&quot;a.txt&quot;)lines = f.readlines()print(type(lines))for line in lines: print line，f.close() 输出结果： 1234&lt;type &apos;list&apos;&gt;HelloWelcomeWhat is the fuck... 四、linecache模块 当然，有特殊需求还可以用linecache模块，比如你要输出某个文件的第n行： 1234#输出第2行 text = linecache.getline(&apos;a.txt&apos;,2)print text 对于大文件效率还可以。 ==总结== 以上就是这篇文章的全部内容了，希望本文的内容对大家的学习或者工作能带来一定的帮助。","categories":[{"name":"python","slug":"python","permalink":"http://fengjianxiong.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://fengjianxiong.cn/tags/python/"}]},{"title":"centos6和centos7修改网卡名的几种方法","slug":"centos6和centos7修改网卡名的几种方法","date":"2018-03-17T20:17:30.000Z","updated":"2018-03-19T20:56:21.211Z","comments":true,"path":"2018/03/18/centos6和centos7修改网卡名的几种方法/","link":"","permalink":"http://fengjianxiong.cn/2018/03/18/centos6和centos7修改网卡名的几种方法/","excerpt":"","text":"centos6与centos7网卡重命名方法 通常网卡名称是系统自动识别的，存在于注册表中，但有些网友因为某些原因想要修改CentOS6.x系统的网卡名称，那么网卡名称要如何更改呢？CentOS 6.X下修改网卡名称有三种方法：方法1： 修改UDEV文件，删除里面的内容；用命令，重新定义名字，两个名字都要改； 方法2： 在centos6中，可以直接使用setup，设置一块新网卡，填上eth1、ip等内容。 在 CentOS 6 中，默认的 kudzu 这个识别硬件的服务不存在了，基本上所有的硬件管理都通过 Udev 来管理了。 如果在 Centos 6 中加了一个新的硬件，如网卡只需要重新启动 udev 就行了。 start_udev 它会重新扫描新加的硬件并做相关的处理。 如果新加的是网卡，或者是例如虚拟机克隆等原因，导致识别不对也或者有时想更新网卡的名字，并不需要编辑/etc/sysconfig/network-scripts/下的内容，向上面运行完后不正常，直接修改 udev 有关网络的配置即可。 有关网络的 udev 的具体网卡序号的配置文件是 /etc/udev/rules.d/70-persistent-net.rules 这个文件。 大概内容如下： SUBSYSTEM==&quot;net&quot;， ACTION==&quot;add&quot;， DRIVERS==&quot;?*&quot;， ATTR{address}==&quot;54:52:00:78:e8:2e&quot;， ATTR{type}==&quot;1&quot;， KERNEL==&quot;eth*&quot;， NAME=&quot;eth1&quot; # PCI device 0x1af4:0x1000 （virtio-pci） SUBSYSTEM==&quot;net&quot;， ACTION==&quot;add&quot;， DRIVERS==&quot;?*&quot;， ATTR{address}==&quot;54:52:00:04:19:6c&quot;， ATTR{type}==&quot;1&quot;， KERNEL==&quot;eth*&quot;，NAME=&quot;eth0&quot; 参照以上内容，最多修改一下 MAC 地址和 NAME 即可。 修改完成后，使用 udev 的命令测试下： udevadm test /sys/class/net/eth0/ 此命令可以很详细的显示 udev 的识别和处理的过程。 注意： 新添加的硬件，如果在 setup 和 system-config-network-tui中添加了网卡，但 /etc/sysconfig/network-scripts/ 找不到配置文件时。 是因为这些命令默认会将生成的配置文件放到/etc/sysconfig/networking/devices/，只要将下面的二个配置文件放到 /etc/sysconfig/network-scripts/，再使用 system-config-network-tui进行配置即可。 代码示例：cp /etc/sysconfig/networking/devices/* /etc/sysconfig/network-scripts/ 然后重新启动后就可以生效了。 方法3： 1、在grub里增加biosdevname=0的启动参数，形如 kernel /vmlinuz-2.6.32-131.21.1.el6.i686 ro root=/dev/mapper/vg_test-lv_root rd_LVM_LV=vg_test/lv_root rd_LVM_LV=vg_test/lv_swap rd_NO_LUKS rd_NO_MD rd_NO_DM LANG=en_US.UTF-8 SYSFONT=latar cyrheb-sun16 KEYBOARDTYPE=pc KEYTABLE=us crashkernel=auto rhgb quiet biosdevname=0 2、删除udev的配置文件rm -f /etc/udev/rules.d/70-persistent-net.rules 3、把网卡配置文件改名 mv ifcfg-em1 ifcfg-eth0 4、把网卡配置文件内容修正，把ens33的全部改成eth0 可以使用 sed -i ‘s/em1/eth0/g’ ifcfg-eth0 进行替换。 5、重启系统即可 CentOS 7.X下修改网卡名称的两种方法： 大家都知道CentOS7默认的网卡名称是和设备名称是随机的，如果要修改网卡名称以 eth 开头，有两种方式，如下： 第一种方式 这种方式适合在安装操作系统的时候进行设置， 点击 Tab，打开kernel启动选项， 末尾增加内核参数： net.ifnames=0 biosdevname=0 输入完成之后回车正常安装操作系统就好了。第二种方式 修改网卡配置文件中的 DEVICE= 参数改为 eth0 [root@centos ~]# cd /etc/sysconfig/network-scripts/ [root@centos network-scripts]# vi ifcfg-ens33 TYPE=Ethernet BOOTPROTO=dhcp DEFROUTE=yes PEERDNS=yes PEERROUTES=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_PEERDNS=yes IPV6_PEERROUTES=yes IPV6_FAILURE_FATAL=no NAME=ens33 UUID=8a3eade8-005c-46df-81f2-6e2598457bac#DEVICE=ens33DEVICE=eth0ONBOOT=yes网卡配置文件名称改为 ifcfg-eth0[root@centos network-scripts]# mv ifcfg-ens33 ifcfg-eth0因 CentOS7 采用 grub2 引导，还需要对 grub2 进行修改，编辑 /etc/default/grub 配置文件，在 GRUB_CMDLINE_LINUX 这个参数后面加入 net.ifnames=0 biosdevname=0[root@centos network-scripts]# vi /etc/default/grub GRUB_TIMEOUT=5 GRUB_DISTRIBUTOR=&quot;$(sed &#39;s, release .*$,,g&#39; /etc/system-release)&quot; GRUB_DEFAULT=saved GRUB_DISABLE_SUBMENU=true GRUB_TERMINAL_OUTPUT=&quot;console&quot; GRUB_CMDLINE_LINUX=&quot;rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet net.ifnames=0 biosdevname=0&quot; GRUB_DISABLE_RECOVERY=&quot;true&quot;用 grub2-mkconfig -o /boot/grub2/grub.cfg 命令重新生成GRUB配置并更新内核[root@centos network-scripts]# grub2-mkconfig -o /boot/grub2/grub.cfg Generating grub configuration file ... Found linux image: /boot/vmlinuz-3.10.0-327.el7.x86_64 Found initrd image: /boot/initramfs-3.10.0-327.el7.x86_64.img Found linux image: /boot/vmlinuz-0-rescue-4dd6b54f74c94bff9e92c61d669fc195 Found initrd image: /boot/initramfs-0-rescue-4dd6b54f74c94bff9e92c61d669fc195.img done重启系统[root@centos network-scripts]# reboot重启之后验证网卡名称:[root@centos ~]# ifconfig eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.56.130 netmask 255.255.255.0 broadcast 192.168.56.255 inet6 fe80::20c:29ff:fe6d:d894 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:6d:d8:94 txqueuelen 1000 (Ethernet) RX packets 27413 bytes 38532163 (36.7 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 7727 bytes 702194 (685.7 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 0 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 以上就是centos6和7修改网卡的几种方法，有意见和建议都可以评论，感谢收看","categories":[{"name":"linux","slug":"linux","permalink":"http://fengjianxiong.cn/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://fengjianxiong.cn/tags/linux/"}]}]}